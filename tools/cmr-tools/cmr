#!/usr/bin/perl
use strict;
use warnings;
use feature qw(switch);

=head1 cmr - convert incoming metadata records into CMR format

=cut

# Set up a library path and base directory relative to the executable,
# then try to load other libraries.
use FindBin;
use lib "$FindBin::Bin/../../CAP/lib";
my $basedir = $FindBin::Bin;

use XML::LibXML;
use XML::LibXSLT;
use CAP::CMR;
use Getopt::Long;

my $xsd_file = "$basedir/cmr.xsd";
my $dump_invalid = 0;
my $debug = 0;
my @xslparam = ();

GetOptions(
    "xsd=s" => \$xsd_file,
    "dump" => \$dump_invalid,
    "debug" => \$debug,
    "param=s" => \@xslparam,
) or die("Usage: $0 [-param=name:value ...] [-xsd=FILE] XSL_FILE INPUT_FILE [OUTPUT_FILE]\n");

my $xsl_file = "$basedir/xsl/" . shift(@ARGV) . ".xsl";
my $input_file = shift(@ARGV);
my $output_file = shift(@ARGV) || "";

my $xml = XML::LibXML->new();
my $xsl = XML::LibXSLT->new();
my $xsd = XML::LibXML::Schema->new(location => $xsd_file);

#
# Transform the source document using the specified stylesheet
#

my %params = ();
foreach my $param (@xslparam) {
    my($key, $value) = split(':', $param, 2);
    $params{$key} = $value;
}

my $doc = $xml->parse_file($input_file);
my $stylesheet = $xsl->parse_stylesheet($xml->parse_file($xsl_file));
$doc = $stylesheet->transform($doc, %params);

#
# Post Processing
#

# Rewrite identifiers (key, pkey, gkey) so that they contain only legal
# characters.
foreach my $key (
    ($doc->findnodes('/recordset/record/key')),
    ($doc->findnodes('/recordset/record/pkey')),
    ($doc->findnodes('/recordset/record/gkey')),
) {
    my $value = $key->findvalue('.');
    $value =~ s/[^A-Za-z0-9_\.\-]/_/g;
    $key->removeChildNodes();
    $key->appendChild($doc->createTextNode($value));
}

#
# Delete language fields that contain illegal characters
#

foreach my $lang ($doc->findnodes('/recordset/record/lang')) {
    my $value = $lang->findvalue('.');
    unless ($value =~ /^[a-z][a-z][a-z]$/) {
        warn("Removing invalid language code: $value\n") if ($debug);
        $lang->parentNode->removeChild($lang);
    }
}

# Convert pubdate values to standardized ISO-8601 dates. If this cannot be
# done, remove the pubdate field altogether.
foreach my $pubdate ($doc->findnodes('/recordset/record/pubdate')) {
    my $min = $pubdate->getAttribute('min');
    my $max = $pubdate->getAttribute('max');
    $min = iso8601($min, 0) unless ($min =~ /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
    $max = iso8601($max, 1) unless ($max =~ /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z$/);
    if ($min && $max && $min !~ /^0000/ && $max !~ /^0000/) {
        $pubdate->setAttribute('min', $min);
        $pubdate->setAttribute('max', $max);
    }
    else {
        $pubdate->parentNode->removeChild($pubdate);
    }
}

# Delete any description fields with zero-length content or illegal
# attribute values
foreach my $field ($doc->findnodes('/recordset/record/description/*')) {
    my $name = $field->nodeName();
    my $text = $field->findvalue('.');
    if ($text =~ /^\s*$/) {
        warn("Removing invalid empty field: $name\n") if ($debug);
        $field->parentNode->removeChild($field);
    }
    elsif ($field->hasAttribute('lang') && $field->getAttribute('lang') !~ /^[a-z][a-z][a-z]$/) {
        my $lang = $field->getAttribute('lang');
        warn("Removing invalid language attribute for $name: '$lang'\n") if ($debug);
        $field->removeAttribute('lang');
    }
}

#
# Filters
#

# Ideally, we'd like to remove this altogether and just do standard
# post-processing.

# Process the filters in order
if ($doc->findnodes('/recordset/filters')) {
    foreach my $filter ($doc->findnodes('/recordset/filters/filter')) {
        my $xpath = $filter->getAttribute('xpath');
        my $attribute = $filter->getAttribute('attribute');
        my $type = $filter->getAttribute('type');
        my $ignore_empty = $filter->getAttribute('ignore-empty') || 'false';
        my $coderef = undef;

        given ($type) {
            when ('code') {
                my $code = $filter->findvalue('.');
                $coderef = eval "sub { $code }";
            }
            when ('default') {
                $coderef = $filter->getAttribute('value');
            }
            when ('map') {
                $coderef = $filter;
            }
            when ('match') {
                $coderef = $filter->getAttribute('regex');
            }
            when ('split') {
                $coderef = $filter->getAttribute('regex');
            }
        }


        # Process each matching node
        foreach my $node ($doc->findnodes($xpath)) {
            my $value;
            if ($attribute) {
                $value = $node->getAttribute($attribute);
            }
            else {
                $value = $node->findvalue('.');
            }
            next if ($ignore_empty eq 'true' && ! $value);

            given ($type) {
                when ('code') {
                    $value = &$coderef($value);
                }
                when ('delete') {
                    $node->parentNode()->removeChild($node);
                    $node = undef;
                }
                when ('default') {
                    $value = $coderef unless ($value);
                }
                when ('map')  {
                    my @map = $coderef->findnodes("map[\@from='$value']");
                    if (@map) {
                        $value = $map[0]->getAttribute('to');
                    }
                }
                when (/^(match)|(split)$/) {
                    my @values;
                    if ($type eq 'match') {
                        @values = ($value =~ m/$coderef/g);
                    }
                    else {
                        @values = split(/$coderef/, $value);
                    }
                    foreach my $match (@values) {
                        my $newnode = $doc->createElement($node->nodeName());
                        $node->parentNode()->insertAfter($newnode, $node);
                        $newnode->appendChild($doc->createTextNode($match));
                        foreach my $attrib (($node->attributes())) {
                            $newnode->setAttribute($attrib->name(), $attrib->value());
                        }
                    }
                    $node->parentNode()->removeChild($node);
                    $node = undef;
                }
            }

            # If we didn't remove the node in the previous step, adjust its
            # value.
            if (! $node) {
                ;
            }
            elsif ($attribute) {
                $node->setAttribute($attribute, $value);
            }
            else {
                $node->removeChildNodes();
                $node->appendChild($doc->createTextNode($value));
            }
        }
    }

    # Remove the filter set, leaving only the CMR record
    my $filters = $doc->findnodes('/recordset/filters')->[0];
    $doc->documentElement()->removeChild($filters);
}

#
# Validate and output the final result
#

eval { $xsd->validate($doc) };
if ($@) {
    my $error = $@;
    print ($doc->toString(1)) if ($dump_invalid);
    die($error);
}

if ($output_file) {
    $doc->toFile($output_file, 1) or die("Failed to write $output_file: $!\n");
}
else {
    print $doc->toString(1) or die("Failed to output document: $!\n");
}
