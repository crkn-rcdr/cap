#!/usr/bin/perl
use strict;
use warnings;

# Set up a library path and base directory relative to the executable,
# then try to load other libraries.
use FindBin;
use lib $FindBin::Bin;
my $basedir = $FindBin::Bin;

use Config::General;
use File::Basename;
use XML::LibXML;
use XML::LibXML::XPathContext;
use XML::LibXSLT;
use feature qw(switch);
use CIHM::CMR::Common;

@ARGV == 4 || die ("Usage: $0 SCHEMA_FILE CONFIG_FILE INPUT_FILE OUTPUT_FILE\n");

my($schema_file, $config_file, $input_file, $output_file) = @ARGV;

# If the config and schema files don't exist, treat them as a
# filename/sub-path relative to basedir.
unless (-f $schema_file) {
    $schema_file = join('/', $basedir, $schema_file);
}
unless (-f $config_file) {
    $config_file = join('/', $basedir, 'config', $config_file);
}

# Read the configuration file and the schema.
my $schema = XML::LibXML::Schema->new(location => $schema_file);
my $config = { Config::General->new($config_file)->getall };

# Parse the source file. Pass it to the preprocesser stylesheet and/or
# plugin, if one is speceified.
my $xml = XML::LibXML->new();
my $doc = XML::LibXML->new()->parse_file($input_file);

my $xsl = XML::LibXSLT->new();

# Strip all namespaces from the source document, if requested.
if ($config->{stripNS}) {
    my $xsl_file = "$FindBin::Bin/xsl/stripNS.xsl";
    my $stylesheet = $xsl->parse_stylesheet($xml->parse_file($xsl_file));
    $doc = $stylesheet->transform($doc);
}

# Preprocess using another stylesheet, if requested.
if ($config->{stylesheet}) {
    my $xsl_file = "$FindBin::Bin/xsl/$config->{stylesheet}.xsl";
    my $stylesheet = $xsl->parse_stylesheet($xml->parse_file($xsl_file));
    $doc = $stylesheet->transform($doc);
}

my $src = XML::LibXML::XPathContext->new($doc->documentElement());

# Register a default namespace.
my @namespaces;
if (! $config->{namespace}) {
    @namespaces = ();
}
elsif (ref($config->{namespace}) eq 'ARRAY') {
    @namespaces = @{$config->{namespace}};
}
else {
    @namespaces = ($config->{namespace});
}
foreach my $ns (@namespaces) {
    my ($name, $uri) = split(':', $ns, 2);
    $src->registerNs($name, $uri);
}

# Get the contributor code
my $contributor = $config->{contributor} or die("Missing contributor declarating in $schema_file\n");

# Load the plugin, if one exists
if ($config->{plugin}) {
    eval "use CIHM::CMR::Plugin::$config->{plugin}";
    die($@) if ($@);
    $doc = preprocess($doc, $src);
}

# Create the output document.
my $cmr    = XML::LibXML::Document->new('1.0', 'UTF-8');
my $cmr_root = element($cmr, undef, 'recordset', {'version' => '1.0'});
$cmr->setDocumentElement($cmr_root);

# There might be just one recordset, or there might be several. Force
# whatever is there into a list we can iterate over.
my @recordset;
if (ref($config->{recordSet}) eq 'ARRAY') {
    @recordset = @{$config->{recordSet}};
}
else{
    @recordset = ($config->{recordSet});
}

foreach my $recordset (@recordset) {
    # Determine the number of records in this record set.
    my $record_base = $recordset->{record};
    my @record_set = $src->findnodes($record_base);

    # Load the filters for this record set.
    my $filters = {};
    foreach my $filter (keys(%{$recordset->{filters}})) {
        $filters->{$filter} = eval "sub { $recordset->{filters}->{$filter} } ";
    }

    # Load the fieldset for this record, replacing the positional
    # parameter with the current record position, and then process the
    # record.
    my $pos = 0;
    foreach my $record (@record_set) {
        ++$pos;
        next if ($recordset->{skip} && $record->findnodes($recordset->{skip}));
        my $fields = {};
        foreach my $field (keys(%{$recordset->{fields}})) {
            $fields->{$field} = $recordset->{fields}->{$field};
            $fields->{$field} =~ s/%%/$pos/g;
        }
        process_record($cmr, $src, $fields, $filters);
    }
}

# Make sure the resulting record is valid
eval { $schema->validate($cmr) };
if ($@) {
    my $error = $@;
    warn ($cmr->toString(1));
    die($error);
}

# Output the CMR record set.
$cmr->toFile($output_file, 1) or die("Failed to write $output_file: $!\n");
exit(0);

my $record;
sub process_record
{
    my($cmr, $src, $fields, $filters) = @_;
    my $cmr_root = $cmr->documentElement();
    my $cmr_record = element($cmr, $cmr_root, 'record', {});

    # Create a skeleton record
    my $record = {
        # Required control data
        type        => undef,
        key         => undef,
        label       => undef,
        clabel      => undef,

        # Optional control data
        pubdate_min => undef,
        pubdate_max => undef,
        pkey        => undef,
        gkey        => [],
        seq         => undef,
        lang        => [],
        media       => [],

        # Description
        ti          => [],
        ti_lang     => [],
        ti_type     => [],
        au          => [],
        au_lang     => [],
        au_type     => [],
        pu          => [],
        pu_lang     => [],
        pu_type     => [],
        su          => [],
        su_lang     => [],
        su_type     => [],
        no          => [],
        no_lang     => [],
        no_type     => [],
        de          => [],
        de_lang     => [],
        de_type     => [],
        tx          => [],
        tx_lang     => [],

        # Resources
        res_curi     => undef,
        res_cprevuri => undef,
        res_cmaster      => undef,
        res_cmaster_mime => undef,
        res_cmaster_size => undef,
        res_cmaster_md5  => undef,
        res_cdownload      => undef,
        res_cdownload_mime => undef,
        res_cdownload_size => undef,
        res_cdownload_md5  => undef,
    };

    # Populate the fields: run the xpath query and submit the content to
    # the filter function, if any.
    foreach my $field (keys(%{$fields})) {
        my $content;
        given ($field) {
            when (/^((gkey)|(lang)|(media)|(ti)|(au)|(pu)|(su)|(no)|(de)|(tx)|(.*_lang)|(.*_type))$/) {
                foreach my $node ($src->findnodes($fields->{$field})) {
                    $content = $node->findvalue('.');
                    $content = $filters->{$field}($content) if ($filters->{$field});
                    push(@{$record->{$field}}, $content);
                }
            }
            default {
                $content = $src->findvalue($fields->{$field});
                $content = $filters->{$field}($content) if ($filters->{$field});
                $record->{$field} = $content
            }
        }
    }

    # Add the elements
    element($cmr, $cmr_record, 'type', {}, $record->{type}, 1);
    element($cmr, $cmr_record, 'contributor', {}, $contributor, 1);
    element($cmr, $cmr_record, 'key', {}, $record->{key}, 1);
    element($cmr, $cmr_record, 'label', {}, $record->{label}, 1);
    element($cmr, $cmr_record, 'clabel', {}, $record->{clabel}, 1);
    element($cmr, $cmr_record, 'pkey', {}, $record->{pkey}, 1);
    for (my $i = 0; $i < @{$record->{gkey}}; ++$i) {
        element($cmr, $cmr_record, 'gkey', {}, $record->{gkey}->[$i]);
    }
    element($cmr, $cmr_record, 'seq', {}, $record->{seq}, 1);
    if ($record->{pubdate_min} && $record->{pubdate_max}) {
        element($cmr, $cmr_record, 'pubdate', {min => $record->{pubdate_min}, max => $record->{pubdate_max}});
    }
    foreach my $field (@{$record->{lang}}) {
        element($cmr, $cmr_record, 'lang', {}, $field);
    }
    foreach my $field (@{$record->{media}}) {
        element($cmr, $cmr_record, 'media', {}, $field);
    }
    my $cmr_description = element($cmr, $cmr_record, 'description');
    for (my $i = 0; $i < @{$record->{ti}}; ++$i) {
        element($cmr, $cmr_description, 'title', { lang => $record->{ti_lang}->[$i], type => $record->{ti_type}->[$i] }, $record->{ti}->[$i]);
    }
    for (my $i = 0; $i < @{$record->{au}}; ++$i) {
        element($cmr, $cmr_description, 'author', { lang => $record->{au_lang}->[$i], type => $record->{au_type}->[$i] }, $record->{au}->[$i]);
    }
    for (my $i = 0; $i < @{$record->{pu}}; ++$i) {
        element($cmr, $cmr_description, 'publication', { lang => $record->{pu_lang}->[$i], type => $record->{pu_type}->[$i] }, $record->{pu}->[$i]);
    }
    for (my $i = 0; $i < @{$record->{su}}; ++$i) {
        element($cmr, $cmr_description, 'subject', { lang => $record->{su_lang}->[$i], type => $record->{su_type}->[$i] }, $record->{su}->[$i]);
    }
    for (my $i = 0; $i < @{$record->{no}}; ++$i) {
        element($cmr, $cmr_description, 'note', { lang => $record->{no_lang}->[$i], type => $record->{no_type}->[$i] }, $record->{no}->[$i]);
    }
    for (my $i = 0; $i < @{$record->{de}}; ++$i) {
        element($cmr, $cmr_description, 'descriptor', { lang => $record->{de_lang}->[$i], type => $record->{de_type}->[$i] }, $record->{de}->[$i]);
    }
    for (my $i = 0; $i < @{$record->{tx}}; ++$i) {
        element($cmr, $cmr_description, 'text', { lang => $record->{tx_lang}->[$i], type => $record->{tx_type}->[$i] }, $record->{tx}->[$i]);
    }
    my $cmr_resource = element($cmr, $cmr_record, 'resource');
    element($cmr, $cmr_resource, 'canonicalUri', {}, $record->{res_curi}, 1);
    element($cmr, $cmr_resource, 'canonicalPreviewUri', {}, $record->{res_cprevuri}, 1);
    element($cmr, $cmr_resource, 'canonicalMaster', { mime => $record->{res_cmaster_mime}, size => $record->{res_cmaster_size}, md5 => $record->{res_cmaster_md5}}, $record->{res_cmaster}, 1);
    element($cmr, $cmr_resource, 'canonicalDownload', { mime => $record->{res_cdownload_mime}, size => $record->{res_cdownload_size}, md5 => $record->{res_cdownload_md5}}, $record->{res_cdownload}, 1);
}

