#!/usr/bin/perl
use strict;
use warnings;
use feature qw( say );
use Config::General;
use XML::LibXML;

# Read the profile configuration file and attempt to validate the
# documents in $solr against them.
#
# This version does not include very much error handling and isn't very
# forgiving of syntax errors in the config file.


my ( $config_file, $solr ) = @ARGV;

my $conf = read_config( $config_file );

my $xml = XML::LibXML->new();
my $solr_add = $xml->parse_file( $solr );

my @errors = ();

foreach my $doc ( $solr_add->findnodes( '//add/doc' )) {
    my $key = $doc->findvalue( 'field[@name="key"]' );
    my $type = $doc->findvalue( 'field[@name="type"]' );

    # We need a key and a type in order to evaluate the document.
    if ( ! $key ) {
        push( @errors, "Found document without a key" );
        next;
    }
    if ( ! $type ) {
        push( @errors,  "Found document key=$key without a type" );
        next;
    }
    if ( ! $conf->{profile}->{$type} ) {
        push( @errors, "Found document key=$key with invalid type \"$type\"" );
        next;
    }

    # Check each field in the document to determine whether the field is
    # allowed to exist and if its content is valid
    foreach my $field ( $doc->findnodes( 'field' )) {
        my $name = $field->getAttribute( 'name' );
        my $content = $field->findvalue( '.' );


        if ( ! $conf->{profile}->{$type}->{$name} ) {
            push( @errors, "Document key=$key ($type) is not allowed to have field \"$name\"" );
        }
        else {
            my ( $repeat, $sig_type ) = split( /\s+/, $conf->{profile}->{$type}->{$name}, 2 );
            die( "No such type: \"$sig_type\"" ) unless ( $conf->{types}->{$sig_type} );

            my ( $sig_format, $signature ) = split( /\s+/, $conf->{types}->{$sig_type}, 2 );
            my $match = 0;

            if ( $sig_format eq 'regex' ) {
                $match = $content =~ /$signature/;
            }
            if ( $sig_format eq 'enum' ) {
                foreach my $enum ( split( /\s+/, $signature )) {
                    if ($content eq $enum) {
                        $match = 1;
                        last;
                    }
                }
            }

            if ( ! $match ) {
                push( @errors, "Document key=$key ($type) contains field \"$name\" that does not match $sig_type: $signature ($content)" );
            }

        }
    }


    # Check each field type in the profile and make sure the count is
    # correct in the document.
    foreach my $field ( keys( %{$conf->{profile}->{$type}} )) {
        my ( $repeat, $sig_type ) = split( /\s+/, $conf->{profile}->{$type}->{$field}, 2 );
        my @nodes = $doc->findnodes( "field[\@name='$field']" );

        if ( $repeat eq '.' && @nodes == 0 ) {
            push( @errors, "Document key=$key ($type) missing required field \"$field\"" );
        }
        elsif ( $repeat eq '+' && @nodes < 1 ) {
            push( @errors, "Document key=$key ($type) missing required field \"$field\"" );
        }
        elsif ( ($repeat eq '?' || $repeat eq '.') && @nodes > 1 ) {
            push( @errors, "Document key=$key ($type) contains multiple instances of field \"$field\"" );
        }
    }
}

say( join( "\n", @errors ));
say( int( @errors ) . " errors" );

exit (1) if (@errors);
exit (0);

# Read and process the profiles configuration file
sub read_config
{
    my ( $config_file ) = @_;
    my $conf = {new Config::General( $config_file )->getall};

    # Replace @include directives within each profile with the content of
    # the corresponding include element.
    foreach my $profile ( keys( %{$conf->{profile}} )) {
        # Get a list of all @include directives for the profile and then
        # remove them.
        my @includes = ();
        if ( $conf->{profile}->{$profile}->{'@include'} ) {
            if ( ref( $conf->{profile}->{$profile}->{'@include'} ) eq 'ARRAY' ) {
                @includes = @{$conf->{profile}->{$profile}->{'@include'}};
            }
            else {
                @includes = ( $conf->{profile}->{$profile}->{'@include'} );
            }
        }
        delete( $conf->{profile}->{$profile}->{'@include'} );

        # Add each element of each include directive to the profile, but
        # skip those which are already defined.
        foreach my $include ( @includes ) {
            foreach my $field ( keys( %{$conf->{include}->{$include}} )) {
                $conf->{profile}->{$profile}->{$field} = $conf->{include}->{$include}->{$field}
                    unless ( $conf->{profile}->{$profile}->{$field} );
            }
        }

    }
    return $conf;
}
