package CAP::Solr::Document;
use strict;
use warnings;
use Carp;
use Moose;
use Moose::Util::TypeConstraints;
use MooseX::Method::Signatures;
use namespace::autoclean;
use WebService::Solr;
use CAP::Solr::Record;
use Digest::SHA qw(sha1_hex);
use URI::Escape;

# Properties from parameters passed to the constructor
has 'key'           => (is => 'ro', isa => 'Str', default => ""); # Document key to retrieve
has 'subset'        => (is => 'ro', isa => 'Str', default => ""); # Document must belong to this subset
has 'solr'          => (is => 'ro', isa => 'WebService::Solr', documentation => 'Solr webservice object'); 
has 'options'       => (is => 'ro', isa => 'HashRef', default => sub{{}});
has 'doc'           => (is => 'ro', isa => 'WebService::Solr::Document');
has 'exists'        => (is => 'ro', isa => 'Int', default => 1); # Was the document found in the Solr index?

# Properties generated at build time
has 'record'        => (is => 'ro', isa => 'CAP::Solr::Record', documentation => 'Access record fields via this object');
has 'child_count'   => (is => 'ro', isa => 'Int', default => 0, documentation => 'number of child records linked to this record');
has 'sibling_count' => (is => 'ro', isa => 'Int', default => 0, documentation => 'number of child records of the parent record');

# Properties generated by methods
has 'active_child'  => (is => 'ro', isa => 'CAP::Solr::Document');

method BUILD {
    # Create parent and child caches so we don't have to look up the same
    # record more than once.
    $self->{_parent_cache} = undef;
    $self->{_child_cache}  = {};

    # If a document record is supplied, use it. Otherwise, look up the
    # supplied key in the database.
    if ($self->doc) {
        $self->{record} = new CAP::Solr::Record($self->doc);
        $self->{key} = $self->doc->value_for('key');;
    }
    elsif ($self->key) {
        # Fetch the requested document
        my $query = "key: " . $self->key;
        if ($self->subset) {
            $query .= ' AND ' . $self->subset;
        }
        my $response = $self->solr->search($query, $self->options);
        croak("Solr query error") unless ($response->ok);
        # Don't croak if the document is not found because it is not
        # generally a system-level error. However, it is important to call
        # ->found() on a newly-constructed document to check whether it
        # actually exists before trying to access it.
        #croak("Requested document not found: " . $self->key) unless ($#{$response->docs} == 0);
        unless ($#{$response->docs} == 0) {
            $self->{exists} = 0;
            return;
        }

        # This lets us access all fields as $self->record->fieldname.
        $self->{record} = new CAP::Solr::Record($response->docs->[0]);
    }
    else {
        croak("Attempt to create new Solr::Document without supplying a key or document");
    }

    # Count the number of child records. Page records should never have children.
    if ($self->record->type ne 'page') {
        $self->{child_count} = $self->solr->search("pkey:" . $self->key, { rows => 0 })->content->{response}->{numFound};
    }

    # Count the number of sibling records (including this one) if it
    # belongs to a parent record.
    if ($self->record->pkey) {
        $self->{sibling_count} = $self->solr->search("pkey:" . $self->record->pkey, { rows => 0 })->content->{response}->{numFound};
    }
}

# Return the document for the parent object. Returns undef if
# there is no parent or there is a retrieval failure.
method parent {
    my $doc;
    return undef unless ($self->record->pkey);
    return $self->{_parent_cache} if ($self->{_parent_cache});
    eval { $doc = new CAP::Solr::Document({ key => $self->record->pkey, solr => $self->solr }) };

    # If we didn't get an actual document, output a warning to stderr to
    # alert us to the fact that we have bad metadata and/or missing
    # records.
    warn(sprintf("Parent record not found: %s", $self->record->pkey)) unless ($doc->exists);

    # Check whether we got a value. Ignore parents that are not of the
    # right type for the document. (This will prevent circular references
    # and other invalid structures.)
    return undef if ($@);
    return undef if ($self->type_is('series'));
    return undef if ($self->type_is('document') && ! $doc->type_is('series'));
    return undef if ($self->type_is('page') && ! $doc->type_is('document'));

    return $self->{_parent_cache} = $doc;
}

# Return whether or not the document has a parent. Useful
# primarily for Template Toolkit.
method has_parent {
    return $self->parent() ? 1 : 0;
}

# Return the document for the $seq'th child object. Returns undef if
# there is no such child or there is a retrieval failure.
method child (Int $seq) {
    my $doc;
    return undef if ($seq > $self->child_count);
    return $self->{_child_cache}->{$seq} if ($self->{_child_cache}->{$seq});
    my $response = $self->solr->search("pkey:" . $self->key, { sort => 'seq asc', rows => 1, start => $seq - 1, fl => 'key' });
    eval { $doc = new CAP::Solr::Document({ key => $response->docs->[0]->value_for('key'), solr => $self->solr }) };

    # Check whether we got a value. Ignore children that are of the wrong
    # type, to prevent circular references and invalid structures.
    return undef if ($@);
    return undef if ($self->type_is('page'));
    return undef if ($self->type_is('document') && ! $doc->type_is('page'));
    return undef if ($self->type_is('series') && ! $doc->type_is('document'));

    return $self->{_child_cache}->{$seq} = $doc;
}

method set_active_child (Int $seq) {
    return $self->{active_child} = $self->child($seq);
}


method canonical_label {
    return ($self->parent ? $self->parent->label . " : " : "") . $self->label;
}

method validate_derivative (Int $seq, Str $size, Str $default_size) {
    my $child = $self->child($seq);
    return [400, $self->key . " does not have page at seq $seq."] unless $child;
    return [400, $child->key . " does not have a canonical master."] unless $child->canonicalMaster;
    return [200, "OK"];
}

method validate_download {
    return [400, "Document " . $self->key . " does not have a canonical download."] unless $self->canonicalDownload;
    return [200, "OK"];
}

# Convenient accessors for fields used internally by cap so we can
# reference them as $self->fieldname rather than $self->record->fieldname
method canonicalDownload { return $self->record->canonicalDownload if $self->exists; }
method canonicalMaster   { return $self->record->canonicalMaster if $self->exists; }
method canonicalUri      { return $self->record->canonicalUri if $self->exists; }
method contributor       { return $self->record->contributor if $self->exists; }
method label             { return $self->record->label if $self->exists; }
method pkey              { return $self->record->pkey if $self->exists; }
method seq               { return $self->record->seq if $self->exists; }
method record_type       { return $self->record->type if $self->exists; }

method type_is (Str $type) {
    return 1 if ($self->record_type eq $type);
    return 0;
}

method found {
    return $self->{exists};
}

__PACKAGE__->meta->make_immutable;
