#!/usr/bin/perl
use strict;
use warnings;
use utf8;

# Parse a METS record and add the title, document and page information to
# CAP. Also generate thesaurus terms.

use Getopt::Long;
use XML::LibXML;
use XML::LibXML::XPathContext;
use FindBin;
use lib "$FindBin::Bin/../lib";
use CAP;

my $c = CAP->new();

# Process the command line and look up the institutional contributor.
my $contributor_id = undef;
GetOptions('contributor=s' => \$contributor_id) or die("\n");
die("You must specify a contributor via the -contributor switch.\n") unless ($contributor_id);
my $contributor = $c->model('DB::Institution')->find({ code => $contributor_id });
die("Cannot find contributing institution '$contributor_id'") unless ($contributor);

if (@ARGV) {
    foreach my $file (@ARGV) {
        process($c, $file, $contributor);
    }
}
else {
    while (my $file = <STDIN>) {
        chomp($file);
        process($c, $file, $contributor);
    }
}

sub process {
    my($c, $file, $contributor) = @_;

    # Parse the file and create an XPath context object with the required
    # namespaces.
    my $xml = XML::LibXML->load_xml(location => $file);
    my $mets = XML::LibXML::XPathContext->new($xml->documentElement());
    $mets->registerNs('mets', 'http://www.loc.gov/METS/');
    $mets->registerNs('dc', 'http://purl.org/dc/elements/1.1/');

    # Get the document identifier
    my $identifier = $mets->findvalue('/mets:mets/@OBJID') or die("Cannot get document ID from file $file");

    # Get the main structMap division and look up the associated metadata.
    my $div = ($mets->findnodes('/mets:mets/mets:structMap/mets:div'))[0];
    die("Can't find valid structMap in $file") unless ($div);
    my $type = $div->getAttribute('TYPE');
    my $dmdid = $div->getAttribute('DMDID');
    my $dmd = ($mets->findnodes("/mets:mets/descendant::mets:dmdSec[\@ID='$dmdid']/mets:mdWrap"))[0];
    die("Can't find dmdSec with \@ID=$dmdid in $file") unless ($dmd);
    my $record = ($mets->findnodes('mets:xmlData', $dmd))[0];
    die("Can't find xmlData within dmdSec witih \@ID=$dmdid in $file") unless ($record);

    # Ignore issues - they do not get their own thesaurus terms.
    return if ($type eq 'issue');

    # Look up the title
    my $title = $c->model('DB::Titles')->find({ identifier => $identifier, institution_id => $contributor->id});
    die("Cannot find record for $identifier") unless ($title);
    print("Processing $type: $identifier\n");

    my $md_type = $dmd->getAttribute('MDTYPE');
    if ($md_type eq 'MARC') {
        die("Can't yet deal with type $md_type");
    }
    elsif ($md_type eq 'DC') {
        process_dc($c, $title, $record, $contributor);
    }
    else {
        die("Don't know how to deal with MDTYPE $md_type in $file");
    }

}

# Process standard MARC records.
sub process_marc {
    my($c, $title, $record, $contributor) = @_;

    # TODO: we aren't going to add subject headings at the moment...
    return 1;

    my $mets = XML::LibXML::XPathContext->new($record);
    $mets->registerNs('mets', 'http://www.loc.gov/METS/');
    $mets->registerNs('marc', 'http://www.loc.gov/MARC21/slim');

    # Parse out the subject headings into thesaurus terms.
    foreach my $marc ($mets->findnodes('/mets:mets/mets:dmdSec/mets:mdWrap[@MDTYPE="MARC"]/mets:xmlData')) {
        foreach my $field (qw(600 610 611 630 648 650 651 653 654 655 656 657 658 662)) {
            foreach my $subject ($mets->findnodes("descendant::marc:datafield[\@tag='$field']", $marc)) {
                if ($subject->getAttribute('ind2') eq '6' || $subject->getAttribute('ind2' eq '9')) {
                    print "RVM Subject in $field\n";
                }
                else {
                    print "LCSH Subject in $field\n";
                }
            }
        }
    }
}


# Process Dublin Core records. As each DC implementation is different, we
# need to implement things differently depending on the contributor and
# specific project.
sub process_dc {
    my($c, $title, $record, $contributor) = @_;

    if ($contributor->code eq 'oop' && substr($title->identifier, 0, 8) eq 'debates_') {
        process_dc_oopDebates($c, $title, $record, $contributor);
    }
}

sub process_dc_oopDebates {
    my($c, $title, $record, $contributor) = @_;

    # Construct a 3-level hierarchy based on the primary identifier field.
    my $identifier = "";
    my $prime_minister = "";
    my $session_date = $record->findvalue('simpledc/dc:coverage[position() = 1]');
    foreach my $idfield ($record->findnodes('simpledc/dc:identifier')) {
        my $value = $idfield->findvalue('.');
        # The principal identifier
        if ($value =~ /^\w{3}-\w{3}-\w{3}$/) {
            $identifier = $value;
        }
        elsif ($value =~ /^PM:/) {
            $prime_minister = substr($value, 3);
        }
    }
    die("No identifier") unless $identifier;

    my($chamber, $parliament, $session) = split(/-/, $identifier);
    my $parl_no = int(substr($parliament, 1));
    my $session_no = int(substr($session, 1));
    my @thesaurus_ids;

    if ($chamber eq 'HOC' || $chamber eq 'CCC') {
        @thesaurus_ids = $c->model('DB::Terms')->create_hierarchy(
            [ 'oop-debates-en', '2-hoc', $parliament, $session ],
            [ 'English', 'House of Commons', sprintf('%s Parliament', ordinal($parl_no, 'en')), sprintf('%s Session: %s (%s)', ordinal($session_no, 'en'), $session_date, $prime_minister)]
        );
        $c->model('DB::TitlesTerms')->add_terms($title, @thesaurus_ids);
    }
    if ($chamber eq 'CDC' || $chamber eq 'CCC') {
        @thesaurus_ids = $c->model('DB::Terms')->create_hierarchy(
            [ 'oop-debates-fr', '2-cdc', $parliament, $session ],
            [ 'Français', 'Chambre des communes', sprintf('%s Législature', ordinal($parl_no, 'fr', 'f')), sprintf('%s Session : %s (%s)', ordinal($session_no, 'fr', 'f'), $session_date, $prime_minister)]
        );
        $c->model('DB::TitlesTerms')->add_terms($title, @thesaurus_ids);
    }
    if ($chamber eq 'SOC' || $chamber eq 'SSS') {
        @thesaurus_ids = $c->model('DB::Terms')->create_hierarchy(
            [ 'oop-debates-en', '1-soc', $parliament, $session ],
            [ 'English', 'Senate', sprintf('%s Parliament', ordinal($parl_no, 'en')), sprintf('%s Session: %s', ordinal($session_no, 'en'), $session_date)]
        );
        $c->model('DB::TitlesTerms')->add_terms($title, @thesaurus_ids);
    }
    if ($chamber eq 'SDC' || $chamber eq 'SSS') {
        @thesaurus_ids = $c->model('DB::Terms')->create_hierarchy(
            [ 'oop-debates-fr', '1-sdc', $parliament, $session ],
            [ 'Français', 'Sénat', sprintf('%s Législature', ordinal($parl_no, 'fr', 'f')), sprintf('%s Session : %s', ordinal($session_no, 'fr', 'f'), $session_date)]
        );
        $c->model('DB::TitlesTerms')->add_terms($title, @thesaurus_ids);
    }

}

sub ordinal {
    my($int, $lang, $gender) = @_;
    my $suffix;

    if ($lang eq 'en') {
        if    (($int % 10 == 1) && ! ($int % 100 == 11)) { $suffix = 'st' }
        elsif (($int % 10 == 2) && ! ($int % 100 == 12)) { $suffix = 'nd' }
        elsif (($int % 10 == 3) && ! ($int % 100 == 13)) { $suffix = 'rd' }
        else  { $suffix = 'th' }
    }
    if ($lang eq 'fr') {
        if    ($int == 1 && $gender eq 'm') { $suffix = 'er' }
        elsif ($int == 1 && $gender ne 'm') { $suffix = 're' }
        else  { $suffix = 'e' }
    }

    return join("", $int, $suffix);
}


# Add subject headings as needed from the MARCXML in the METS record and
# add the document as part of those headings.
sub add_marc {
    my($file) = @_;
    my $xml = XML::LibXML->load_xml(location => $file);
    my $contributor = 'ooe';
    my $collection = 'dfait';

    my $mets = XML::LibXML::XPathContext->new($xml->documentElement());
    $mets->registerNs('mets', 'http://www.loc.gov/METS/');
    $mets->registerNs('marc', 'http://www.loc.gov/MARC21/slim');

    my $doc_id = $mets->findvalue('/mets:mets/@OBJID');

    $c->model('DB::DocumentCollection')->update_or_create(contributor => $contributor, id => $doc_id, collection => $collection);

    foreach my $marc ($mets->findnodes('/mets:mets/mets:dmdSec/mets:mdWrap[@MDTYPE="MARC"]/mets:xmlData')) {

        foreach my $field (qw(600 610 611 630 648 650 651 653 654 655 656 657 658 662)) {
            foreach my $subject ($mets->findnodes("descendant::marc:datafield[\@tag='$field']", $marc)) {
                my @path = ();;

                # Establish the root term, if it does not yet exist. A '9'
                # in indicator 2 might be an old UTLAS indicator for RVM.
                # Assume anything not 6 or 9 is a 0 or 5, which we will
                # treat both as LCSH.
                if ($subject->getAttribute('ind2') eq '6' || $subject->getAttribute('ind2' eq '9')) {
                    push(@path, 'RVM');
                    my $id = $c->model('DB::Thesaurus')->add_term('Répertoire de vedettes-matière', @path);
                    $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $id});
                }
                else {
                    push(@path, 'LCSH');
                    my $id = $c->model('DB::Thesaurus')->add_term('Library of Congress Subject Headings', @path);
                    $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $id});
                }

                # Add all sub-terms
                foreach my $subfield ($mets->findnodes("marc:subfield", $subject)) {
                    my $label = $subfield->findvalue('.');

                    # Create and normalize the term
                    my $term  = $label;
                    $term =~ s/\s+/ /g;
                    $term = uc($term);
                    $term =~ s/[^A-Z ]//g;
                    # TODO: more, including changing accented characters to
                    # base characters.

                    push(@path, $term);
                    my $id = $c->model('DB::Thesaurus')->add_term($label, @path);
                    $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $id});
                }
            }
        }
    }
}
