#!/usr/bin/perl
use strict;
use warnings;
use utf8;

# Parse a METS record and add the title, document and page information to
# CAP. Also generate thesaurus terms.

use Getopt::Long;
use XML::LibXML;
use XML::LibXML::XPathContext;
use FindBin;
use lib "$FindBin::Bin/../lib";
use CAP;

my $c = CAP->new();
my $contributor_id = undef;
my $portals = [];
GetOptions('contributor=s' => \$contributor_id, 'portals=s@' => \$portals) or die("\n");
die("You must specify a contributor via the -contributor switch.\n") unless ($contributor_id);

my $contributor = $c->model('DB::Institution')->find({ code => $contributor_id });
die("Cannot find contributing institution '$contributor_id'") unless ($contributor);

if (@ARGV) {
    foreach my $file (@ARGV) {
        process($c, $file, $contributor, $portals);
    }
}
else {
    while (my $file = <STDIN>) {
        chomp($file);
        process($c, $file, $contributor, $portals);
    }
}

sub process {
    my($c, $file, $contributor, $portals) = @_;

    # Parse the file and create an XPath context object with the required
    # namespaces.
    my $xml = XML::LibXML->load_xml(location => $file);
    my $mets = XML::LibXML::XPathContext->new($xml->documentElement());
    $mets->registerNs('mets', 'http://www.loc.gov/METS/');
    $mets->registerNs('dc', 'http://purl.org/dc/elements/1.1/');
    $mets->registerNs('issueinfo', 'http://canadiana.ca/schema/2012/xsd/issueinfo');

    # Get the document identifier
    my $identifier = $mets->findvalue('/mets:mets/@OBJID') or die("Cannot get document ID from file $file");

    # Add the title, document and page information if it is missing.
    foreach my $div ($mets->findnodes('/mets:mets/mets:structMap/mets:div')) {
        my $type = $div->getAttribute('TYPE');
        my $label = $div->getAttribute('LABEL');

        # Series records
        if ($type eq 'series') {
            my $title = $c->model('DB::Titles')->update_or_create({
                institution_id => $contributor->id,
                identifier => $identifier,
                label => $label
            });

            # Add the document to listed portals, if specified.
            foreach my $portal (@{$portals}) {
                $c->model('DB::PortalsTitles')->update_or_create({ portal_id => $portal, title_id => $title->id });
            }

            foreach my $record ($mets->findnodes('/mets:mets/mets:dmdSec/mets:mdWrap[@MDTYPE="DC"]/mets:xmlData')) {
                process_dc($c, $title, $record, $contributor);
            }
            foreach my $record ($mets->findnodes('/mets:mets/mets:dmdSec/mets:mdWrap[@MDTYPE="MARC"]/mets:xmlData')) {
                warn "MARC record: $record\n";
            }

        }

        # Issue records
        elsif ($type eq 'issue') {
            die("Ooops... not an issue")
                unless ($mets->findvalue('/mets:mets/mets:structMap/mets:div/@TYPE') eq 'issue');

            # Get the dmdSec identifier
            my $dmdid = $mets->findvalue('/mets:mets/mets:structMap/mets:div/@DMDID');

            # Get the parent identifier
            my $parent_id = $mets->findvalue("descendant::mets:dmdSec[\@ID='$dmdid']/descendant::issueinfo:series")
                or die("Can't get parent ID for $identifier");

            my $sequence = $mets->findvalue(
            '/mets:mets/mets:dmdSec/mets:mdWrap[@OTHERMDTYPE="issueinfo"]/mets:xmlData/issueinfo:issueinfo/issueinfo:sequence'
            ) or die("Can't get sequence for $identifier (TODO: should not be fatal, assume null)");

            # Find the title that the document belongs to.
            my $title = $c->model('DB::Titles')->find({ institution_id => $contributor->id, identifier => $parent_id});
            if (! $title) {
                warn("Can't process issue $identifier ($label) yet: no parent record $parent_id");
                next;
            }

            # Add to the documents table.
            my $document = $c->model('DB::Documents')->update_or_create({
                title_id => $title->id, 
                identifier => $identifier,
                sequence => $sequence,
                label => $label
            });

            # Add the document pages
            my $pg_sequence = 0;
            foreach my $page ($mets->findnodes('/mets:mets/mets:structMap/mets:div/mets:div')) {
                ++$pg_sequence;
                my $type = $page->getAttribute('TYPE');
                my $pg_identifier = "$identifier.$pg_sequence";
                my $dmdid = $page->getAttribute('DMDID');
                my $label = $page->getAttribute('LABEL');
                die("Ooops... type for $pg_identifier should be page, but is $type") unless ($type eq 'page');

                $c->model('DB::Pages')->update_or_create({
                    document_id => $document->id,
                    identifier => $pg_identifier,
                    sequence => $pg_sequence,
                    label => $label
                });
            }

        }

        else {
            die("Don't know what to do with type '$type'");
        }
    }
}

sub process_dc {
    my($c, $title, $record, $contributor) = @_;

    if ($contributor->code eq 'oop' && substr($title->identifier, 0, 8) eq 'debates_') {
        process_dc_oopDebates($c, $title, $record, $contributor);
    }
}

sub process_dc_oopDebates {
    my($c, $title, $record, $contributor) = @_;

    # Construct a 3-level hierarchy based on the primary identifier field.
    my $identifier = $record->findvalue('simpledc/dc:identifier[position() = 1]') or return 0;
    my($chamber, $parliament, $session) = split(/-/, $identifier);
    my $parl_no = int(substr($parliament, 1));
    my $session_no = int(substr($session, 1));
    my @thesaurus_ids;

    if ($chamber eq 'HOC') {
        @thesaurus_ids = $c->model('DB::Terms')->create_hierarchy(
            [ 'oop-debates-en', '2-hoc', $parliament, $session ],
            [ 'English', 'House of Commons', sprintf('%s Parliament', ordinal($parl_no, 'en')), sprintf('%s Session', ordinal($session_no, 'en'))]
        );
    }
    elsif ($chamber eq 'CDC') {
        @thesaurus_ids = $c->model('DB::Terms')->create_hierarchy(
            [ 'oop-debates-fr', '2-cdc', $parliament, $session ],
            [ 'Français', 'Chambre des communes', sprintf('%s Législature', ordinal($parl_no, 'fr', 'f')), sprintf('%s Session', ordinal($session_no, 'fr', 'f'))]
        );
    }
    elsif ($chamber eq 'SOC') {
        @thesaurus_ids = $c->model('DB::Terms')->create_hierarchy(
            [ 'oop-debates-en', '1-soc', $parliament, $session ],
            [ 'English', 'Senate of Canada', sprintf('%s Parliament', ordinal($parl_no, 'en')), sprintf('%s Session', ordinal($session_no, 'en'))]
        );
    }
    elsif ($chamber eq 'SDC') {
        @thesaurus_ids = $c->model('DB::Terms')->create_hierarchy(
            [ 'oop-debates-fr', '1-sdc', $parliament, $session ],
            [ 'Français', 'Sénat du Canada', sprintf('%s Législature', ordinal($parl_no, 'fr', 'f')), sprintf('%s Session', ordinal($session_no, 'fr', 'f'))]
        );
    }

    # Add all terms to this title.
    $c->model('DB::TitlesTerms')->add_terms($title, @thesaurus_ids);
}

sub ordinal {
    my($int, $lang, $gender) = @_;
    my $suffix;

    if ($lang eq 'en') {
        if    (($int % 10 == 1) && ! ($int % 100 == 11)) { $suffix = 'st' }
        elsif (($int % 10 == 2) && ! ($int % 100 == 12)) { $suffix = 'nd' }
        elsif (($int % 10 == 3) && ! ($int % 100 == 13)) { $suffix = 'rd' }
        else  { $suffix = 'th' }
    }
    if ($lang eq 'fr') {
        if    ($int == 1 && $gender eq 'm') { $suffix = 'er' }
        elsif ($int == 1 && $gender ne 'm') { $suffix = 're' }
        else  { $suffix = 'e' }
    }

    return join("", $int, $suffix);
}


# Add subject headings as needed from the MARCXML in the METS record and
# add the document as part of those headings.
sub add_marc {
    my($file) = @_;
    my $xml = XML::LibXML->load_xml(location => $file);
    my $contributor = 'ooe';
    my $collection = 'dfait';

    my $mets = XML::LibXML::XPathContext->new($xml->documentElement());
    $mets->registerNs('mets', 'http://www.loc.gov/METS/');
    $mets->registerNs('marc', 'http://www.loc.gov/MARC21/slim');

    my $doc_id = $mets->findvalue('/mets:mets/@OBJID');

    $c->model('DB::DocumentCollection')->update_or_create(contributor => $contributor, id => $doc_id, collection => $collection);

    foreach my $marc ($mets->findnodes('/mets:mets/mets:dmdSec/mets:mdWrap[@MDTYPE="MARC"]/mets:xmlData')) {

        foreach my $field (qw(600 610 611 630 648 650 651 653 654 655 656 657 658 662)) {
            foreach my $subject ($mets->findnodes("descendant::marc:datafield[\@tag='$field']", $marc)) {
                my @path = ();;

                # Establish the root term, if it does not yet exist. A '9'
                # in indicator 2 might be an old UTLAS indicator for RVM.
                # Assume anything not 6 or 9 is a 0 or 5, which we will
                # treat both as LCSH.
                if ($subject->getAttribute('ind2') eq '6' || $subject->getAttribute('ind2' eq '9')) {
                    push(@path, 'RVM');
                    my $id = $c->model('DB::Thesaurus')->add_term('Répertoire de vedettes-matière', @path);
                    $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $id});
                }
                else {
                    push(@path, 'LCSH');
                    my $id = $c->model('DB::Thesaurus')->add_term('Library of Congress Subject Headings', @path);
                    $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $id});
                }

                # Add all sub-terms
                foreach my $subfield ($mets->findnodes("marc:subfield", $subject)) {
                    my $label = $subfield->findvalue('.');

                    # Create and normalize the term
                    my $term  = $label;
                    $term =~ s/\s+/ /g;
                    $term = uc($term);
                    $term =~ s/[^A-Z ]//g;
                    # TODO: more, including changing accented characters to
                    # base characters.

                    push(@path, $term);
                    my $id = $c->model('DB::Thesaurus')->add_term($label, @path);
                    $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $id});
                }
            }
        }
    }
}
