#!/usr/bin/perl
use strict;
use warnings;
use utf8;

# Parse a METS record and add the title, document and page information to
# CAP. Also generate thesaurus terms.

use Getopt::Long;
use XML::LibXML;
use XML::LibXML::XPathContext;
use FindBin;
use lib "$FindBin::Bin/../lib";
use CAP;

my $c = CAP->new();
my $contributor_id = undef;
my $collections = [];
GetOptions('contributor=s' => \$contributor_id, 'collection=s@' => \$collections) or die("\n");
die("You must specify a contributor via the -contributor switch.\n") unless ($contributor_id);

my $contributor = $c->model('DB::Institution')->find({ code => $contributor_id });
die("Cannot find contributing institution '$contributor_id'") unless ($contributor);

if (@ARGV) {
    foreach my $file (@ARGV) {
        process($c, $file, $contributor, $collections);
    }
}
else {
    while (my $file = <STDIN>) {
        chomp($file);
        process($c, $file, $contributor, $collections);
    }
}

sub process {
    my($c, $file, $contributor, $collections) = @_;

    # Parse the file and create an XPath context object with the required
    # namespaces.
    my $xml = XML::LibXML->load_xml(location => $file);
    my $mets = XML::LibXML::XPathContext->new($xml->documentElement());
    $mets->registerNs('mets', 'http://www.loc.gov/METS/');
    $mets->registerNs('dc', 'http://canadiana.ca/schema/2012/xsd/cmr');

    # Get the document identifier
    my $identifier = $mets->findvalue('/mets:mets/@OBJID') or die("Cannot get document ID from file $file");

    # Add the title, document and page information if it is missing.
    foreach my $div ($mets->findnodes('/mets:mets/mets:structMap/mets:div')) {
        my $type = $div->getAttribute('TYPE');
        my $label = $div->getAttribute('LABEL');

        # Add the title to the database.
        if ($type eq 'series') {
            my $title = $c->model('DB::Titles')->update_or_create({
                institution_id => $contributor->id,
                identifier => $identifier,
                label => $label
            });

            # Add the document to listed collections, if specified.
            #foreach my $collection (@{$collections}) {
            #    $c->model('DB::DocumentCollection')->update_or_create(contributor => $contributor, id => $doc_id, collection => $collection);
            #}

            foreach my $record ($mets->findnodes('/mets:mets/mets:dmdSec/mets:mdWrap[@MDTYPE="DC"]/mets:xmlData')) {
                process_dc($c, $title, $record, $contributor);
            }
            foreach my $record ($mets->findnodes('/mets:mets/mets:dmdSec/mets:mdWrap[@MDTYPE="MARC"]/mets:xmlData')) {
                warn "MARC record: $record\n";
            }

        }
        else {
            die("Don't know what to do with type '$type'");
        }
    }
}

sub process_dc {
    my($c, $title, $record, $contributor) = @_;

    if ($contributor->code eq 'oop' && substr($title->identifier, 0, 8) eq 'debates_') {
        process_dc_oopDebates($c, $title, $record, $contributor);
    }
}

sub process_dc_oopDebates {
    my($c, $title, $record, $contributor) = @_;

    # Construct a 3-level hierarchy based on the primary identifier field.
    my $identifier = $record->findvalue('simpledc/dc:identifier[position() = 1]') or return 0;
    my($chamber, $parliament, $session) = split(/-/, $identifier);
    my $parl_no = int(substr($parliament, 1));
    my $session_no = int(substr($session, 1));
    my @thesaurus_ids;

    if ($chamber eq 'HOC') {
        @thesaurus_ids = $c->model('DB::Thesauruses')->create_hierarchy(
            [ 'oop-hoc', $parliament, $session ],
            [ 'House of Commons', sprintf('%s Parliament', ordinal($parl_no, 'en')), sprintf('%s Session', ordinal($session_no, 'en'))]
        );
    }
    elsif ($chamber eq 'CDC') {
        @thesaurus_ids = $c->model('DB::Thesauruses')->create_hierarchy(
            [ 'oop-cdc', $parliament, $session ],
            [ 'Chambre des communes', sprintf('%s Législature', ordinal($parl_no, 'fr', 'f')), sprintf('%s Session', ordinal($session_no, 'fr', 'f'))]
        );
    }
    elsif ($chamber eq 'SOC') {
        @thesaurus_ids = $c->model('DB::Thesauruses')->create_hierarchy(
            [ 'oop-soc', $parliament, $session ],
            [ 'Senate of Canada', sprintf('%s Parliament', ordinal($parl_no, 'en')), sprintf('%s Session', ordinal($session_no, 'en'))]
        );
    }
    elsif ($chamber eq 'SDC') {
        @thesaurus_ids = $c->model('DB::Thesauruses')->create_hierarchy(
            [ 'oop-sdc', $parliament, $session ],
            [ 'Sénat du Canada', sprintf('%s Législature', ordinal($parl_no, 'fr', 'f')), sprintf('%s Session', ordinal($session_no, 'fr', 'f'))]
        );
    }

    # Add all terms to this title.
    $c->model('DB::TitlesThesauruses')->add_terms($title, @thesaurus_ids);
}

sub ordinal {
    my($int, $lang, $gender) = @_;
    my $suffix;

    if ($lang eq 'en') {
        if    (($int % 10 == 1) && ! ($int % 100 == 11)) { $suffix = 'st' }
        elsif (($int % 10 == 2) && ! ($int % 100 == 12)) { $suffix = 'nd' }
        elsif (($int % 10 == 3) && ! ($int % 100 == 13)) { $suffix = 'rd' }
        else  { $suffix = 'th' }
    }
    if ($lang eq 'fr') {
        if    ($int == 1 && $gender eq 'm') { $suffix = 'er' }
        elsif ($int == 1 && $gender ne 'm') { $suffix = 're' }
        else  { $suffix = 'e' }
    }

    return join("", $int, $suffix);
}


# Add parliamentary hiserarchical browsing data based on the DC
# identifier.
sub add_dc {
    my($file) = @_;
    my $xml = XML::LibXML->load_xml(location => $file);
    my $contributor = 'oop';
    my $collection = 'oop';

    my $mets = XML::LibXML::XPathContext->new($xml->documentElement());
    $mets->registerNs('mets', 'http://www.loc.gov/METS/');
    $mets->registerNs('dc', 'http://canadiana.ca/schema/2012/xsd/cmr');

    my $doc_id = $mets->findvalue('/mets:mets/@OBJID');

    $c->model('DB::DocumentCollection')->update_or_create(contributor => $contributor, id => $doc_id, collection => $collection);

    foreach my $dc ($mets->findnodes('/mets:mets/mets:dmdSec/mets:mdWrap[@MDTYPE="DC"]/mets:xmlData')) {
        my $identifier = $dc->findvalue('simpledc/dc:identifier');
        my($chamber, $parliament, $session) = split(/-/, $identifier);

        my $p_no = substr($parliament, 1);
        my $s_no = substr($session, 1);
        my $chamber_name;
        my $parliament_name;
        my $session_name;
        if ($chamber eq 'HOC') {
            $chamber_name = "House of Commons";
            $parliament_name = sprintf("Parliament %d", $p_no);
            $session_name = sprintf("Session %d", $s_no);
        }
        elsif ($chamber eq 'CDC') {
            $chamber_name = "Chambre des communes";
            $parliament_name = sprintf("Législature %d", $p_no);
            $session_name = sprintf("Session %d", $s_no);
        }
        elsif ($chamber eq 'SOC') {
            $chamber_name = "Senate of Canada";
            $parliament_name = sprintf("Parliament %d", $p_no);
            $session_name = sprintf("Session %d", $s_no);
        }
        elsif ($chamber eq 'SDC') {
            $chamber_name = "Sénat du Canada";
            $parliament_name = sprintf("Législature %d", $p_no);
            $session_name = sprintf("Session %d", $s_no);
        }

        # Establish all three terms, if they don't exist.
        my $thesaurus_id;
        $thesaurus_id = $c->model('DB::Thesaurus')->add_term($chamber_name, $chamber);
        $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $thesaurus_id});
        $thesaurus_id = $c->model('DB::Thesaurus')->add_term($parliament_name, $chamber, $parliament);
        $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $thesaurus_id});
        $thesaurus_id = $c->model('DB::Thesaurus')->add_term($session_name, $chamber, $parliament, $session);
        $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $thesaurus_id});

    }
}

# Add subject headings as needed from the MARCXML in the METS record and
# add the document as part of those headings.
sub add_marc {
    my($file) = @_;
    my $xml = XML::LibXML->load_xml(location => $file);
    my $contributor = 'ooe';
    my $collection = 'dfait';

    my $mets = XML::LibXML::XPathContext->new($xml->documentElement());
    $mets->registerNs('mets', 'http://www.loc.gov/METS/');
    $mets->registerNs('marc', 'http://www.loc.gov/MARC21/slim');

    my $doc_id = $mets->findvalue('/mets:mets/@OBJID');

    $c->model('DB::DocumentCollection')->update_or_create(contributor => $contributor, id => $doc_id, collection => $collection);

    foreach my $marc ($mets->findnodes('/mets:mets/mets:dmdSec/mets:mdWrap[@MDTYPE="MARC"]/mets:xmlData')) {

        foreach my $field (qw(600 610 611 630 648 650 651 653 654 655 656 657 658 662)) {
            foreach my $subject ($mets->findnodes("descendant::marc:datafield[\@tag='$field']", $marc)) {
                my @path = ();;

                # Establish the root term, if it does not yet exist. A '9'
                # in indicator 2 might be an old UTLAS indicator for RVM.
                # Assume anything not 6 or 9 is a 0 or 5, which we will
                # treat both as LCSH.
                if ($subject->getAttribute('ind2') eq '6' || $subject->getAttribute('ind2' eq '9')) {
                    push(@path, 'RVM');
                    my $id = $c->model('DB::Thesaurus')->add_term('Répertoire de vedettes-matière', @path);
                    $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $id});
                }
                else {
                    push(@path, 'LCSH');
                    my $id = $c->model('DB::Thesaurus')->add_term('Library of Congress Subject Headings', @path);
                    $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $id});
                }

                # Add all sub-terms
                foreach my $subfield ($mets->findnodes("marc:subfield", $subject)) {
                    my $label = $subfield->findvalue('.');

                    # Create and normalize the term
                    my $term  = $label;
                    $term =~ s/\s+/ /g;
                    $term = uc($term);
                    $term =~ s/[^A-Z ]//g;
                    # TODO: more, including changing accented characters to
                    # base characters.

                    push(@path, $term);
                    my $id = $c->model('DB::Thesaurus')->add_term($label, @path);
                    $c->model('DB::DocumentThesaurus')->find_or_create({contributor => $contributor, id => $doc_id, thesaurus_id => $id});
                }
            }
        }
    }
}
