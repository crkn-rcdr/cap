#!/usr/bin/perl
use strict;
use warnings;
use utf8;

=head1 import-record

Import record(s) into the cap titles, documents and pages tables.

=cut

use Getopt::Long;
use XML::LibXML;
use XML::LibXML::XPathContext;
use FindBin;
use lib "$FindBin::Bin/../lib";
use CAP;

my $c = CAP->new();
my $portals = [];
my $root;
my $updated_time = DateTime->now();
GetOptions(
    'portals=s@' => \$portals,
    'root=s' => \$root
) or die("\n");


my %CONTRIBUTORS = ();
my @NEXT_QUEUE = ();
my @QUEUE = ();

# Build the initial queue of files to process from the command line or stdin.
if ($root) {
    my $lastupdate = $c->model('DB::Info')->find('import-cmr');
    my $mtime = 0;
    if ($lastupdate && $lastupdate->time) {
        $mtime = $lastupdate->time->clone();
        $mtime->subtract_duration(DateTime::Duration->new(hours => 24));
        print("Last updated on " . $lastupdate->time . "\n");
        print("Updating records changed since " . $mtime . "\n");
    }
    else {
        print("Can't find lastmod time\n");
    }
    my @cmr_list = ();
    find_cmr($root, \@cmr_list);
    foreach my $cmr (@cmr_list) {
        my @cmr_stat = stat($cmr) or die("Cannot stat $cmr: $!");
        if ($cmr_stat[9] > $mtime->epoch()) {
            push(@NEXT_QUEUE, $cmr);
        }
    }
}
elsif (@ARGV) {
    print "ARGV\n";
    @NEXT_QUEUE = @ARGV;
}
else {
    while (my $file = <STDIN>) {
        chomp($file);
        push(@NEXT_QUEUE, $file);
    }
}

my $passes = 3; # We may need up to 3 passes to get the dependencies correct
for (my $pass = 1; $pass <= $passes; ++$pass) {

    # Prepare the queue for this pass
    @QUEUE = @NEXT_QUEUE;
    @NEXT_QUEUE = ();

    # If there are no files left to process, 
    if (@QUEUE == 0) {
        printf("Finished on pass %d\n", $pass - 1);
        update_timestamp() if ($root);
        exit 0;
    }

    printf("Starting pass %d of %d with %d files\n", $pass, $passes, int(@QUEUE));

    # Process the queue. Put any files that are not fully processed back
    # on to the next queue.
    my $count = 0;
    my $queue_size = int(@QUEUE);
    $| = 1;
    while(my $file = shift(@QUEUE)) {
        die("No such file: $file\n") unless (-f $file);
        printf("Pass: %d of %d; file: %d of %d (%d deferred)\r", $pass, $passes, ++$count, $queue_size, int(@NEXT_QUEUE));
        if (! process($c, $file, $portals)) {
            push(@NEXT_QUEUE, $file);
        }
    }
}

foreach my $file (@NEXT_QUEUE) {
    print("Failed to process all records in $file\n");
}
printf("Record(s) from %d files were not processed\n", int(@NEXT_QUEUE)) if (@NEXT_QUEUE);

update_timestamp() if ($root);
exit(0);

# If we are doing a timestamp-based update, set the updated time.
sub update_timestamp {
    if ($root) {
        print("Seting last updated time to " . $updated_time . "\n");
        $c->model('DB::Info')->update_or_create({
            name => 'import-cmr',
            time => $updated_time,
        });
    }
}


sub process {
    my($c, $file, $portals) = @_;
    my $deferred_newline = 0;
    my $all_ok = 1;

    # Parse the file and create an xpath context
    my $xml = XML::LibXML->load_xml(location => $file);
    my $xpc = XML::LibXML::XPathContext->new($xml->documentElement());
    $xpc->registerNs('cmr', 'http://canadiana.ca/schema/2012/xsd/cmr');

    # Determine if we are dealing with a namespace or namespaceless CMR
    # record and create the appropriate xpath queries
    my $xpc_record;
    my $xpc_type;
    my $xpc_contributor;
    my $xpc_key;
    my $xpc_pkey;
    my $xpc_label;
    my $xpc_seq;
    if ($xpc->findnodes('/recordset')) {
        $xpc_record = '/recordset/record';
        $xpc_type = 'type';
        $xpc_contributor = 'contributor';
        $xpc_key = 'key';
        $xpc_pkey = 'pkey';
        $xpc_label = 'label';
        $xpc_seq = 'seq';
    }
    elsif ($xpc->findnodes('/cmr:recordset')) {
        $xpc_record = '/cmr:recordset/cmr:record';
        $xpc_type = 'cmr:type';
        $xpc_contributor = 'cmr:contributor';
        $xpc_key = 'cmr:key';
        $xpc_pkey = 'cmr:pkey';
        $xpc_label = 'cmr:label';
        $xpc_seq = 'cmr:seq';
    }
    else {
        die("Don't know what kind of record $file is\n");
    }

    # Process each record within the recordset.
    my $page_seq = 0;
    foreach my $record ($xpc->findnodes($xpc_record)) {
        my $type = $xpc->findvalue($xpc_type, $record);
        my $contributor = $xpc->findvalue($xpc_contributor, $record);
        my $key = $xpc->findvalue($xpc_key, $record);
        my $pkey = $xpc->findvalue($xpc_pkey, $record);
        my $label = $xpc->findvalue($xpc_label, $record);
        my $seq = $xpc->findvalue($xpc_seq, $record);

        # Convert obsolete types to modern ones
        $type = 'document' if ($type eq 'monograph');
        $type = 'document' if ($type eq 'issue');
        $type = 'series'   if ($type eq 'serial');

        # Look up the contributor ID
        my $contributor_id = contributor_lookup($c, $contributor);

        if ($type eq 'series') {
            my $title = add_title($contributor_id, $key, $label, $portals);
        }
        elsif ($type eq 'document') {
            # Document is an issue in a series
            if ($pkey) {
                my $title = $c->model('DB::Titles')->find({
                    institution_id => $contributor_id,
                    identifier => $pkey
                });
                if ($title) {
                    my $document = $c->model('DB::Documents')->update_or_create({
                        title_id => $title->id, 
                        identifier => $key,
                        label => $label
                    });
                }
                else {
                    print("No parent series $pkey yet for $key\n");
                    $all_ok = 0;
                }
            }
            
            # Document is a monograph
            else {
                my $title = add_title($contributor_id, $key, $label, $portals);
                my $document = $c->model('DB::Documents')->update_or_create({
                    title_id => $title->id, 
                    identifier => $key,
                    label => $label
                });
            }
        }
        elsif ($type eq 'page') {
            # If the page has no sequence, use an artificial number. This
            # can result in significant data loss for documents with
            # inconistent page sequencing, but is the best way to try to
            # handle CMR records that don't follow best practices.
            ++$page_seq;
            $seq = $page_seq unless ($seq);

            my $document = $c->model('DB::Documents')->by_identifier($pkey, $contributor_id);
            if ($document) {
                my $page = $c->model('DB::Pages')->update_or_create({
                    document_id => $document->id,
                    sequence => $seq,
                    label => $label,
                });
            }
            else {
                print("Did not find parent doucment $pkey for page $key\r");
                $deferred_newline = 1;
                $all_ok = 0;
            }
        }
        else {
            die("Don't know how to handle document type $type");
        }
    }

    print("\n") if ($deferred_newline);
    return $all_ok;
}


# Returns the CAP contributor id for $code.
sub contributor_lookup {
    my($c, $code) = @_;

    # If the ID is already cached, return the cached value
    return $CONTRIBUTORS{$code} if ($CONTRIBUTORS{$code});

    # Otherwise, look it up
    my $contributor = $c->model('DB::Institution')->find({ code => $code });

    die("Lookup of contributor code $code failed") unless ($contributor);
    $CONTRIBUTORS{$code} = $contributor->id;
    return $contributor->id;
}

# Create or update the title and add it to all of the portals listed in
# @{$portals}
sub add_title {
    my($contributor_id, $key, $label, $portals) = @_;
    my $title = $c->model('DB::Titles')->update_or_create({
        institution_id => $contributor_id,
        identifier => $key,
        label => $label
    });

    foreach my $portal_id (@${portals}) {
        my $portal = $c->model('DB::Portal')->find({ id => $portal_id });
        die("Nonexistent portal: $portal_id") unless ($portal);
        $c->model('DB::PortalsTitles')->update_or_create({
            portal_id => $portal->id,
            title_id => $title->id,
            hosted => 1
        });
    }

    return $title;
}

# Find CMR records at or below the specified root $dir.
sub find_cmr {
    my($dir, $cmr_list) = @_;
    die("$dir is not a directory") unless (-d $dir);

    my $bagit_file = join('/', $dir, 'bagit.txt');
    my $cmr_file = join('/', $dir, 'data', 'cmr.xml');

    if (-f $bagit_file) {
        if (-f $cmr_file) {
            push(@{$cmr_list}, $cmr_file);
        }
    }

    else {
        opendir(my $dh, $dir) or die("Cannot read directory $dir: $!");
        while (my $dirent = readdir($dh)) {
            next if ($dirent eq '.' || $dirent eq '..');
            my $path = join('/', $dir, $dirent);
            if (-d $path) {
                find_cmr($path, $cmr_list);
            }
        }
        closedir($dh);
    }

}
